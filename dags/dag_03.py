# link kestra https://github.com/DataTalksClub/data-engineering-zoomcamp/blob/main/02-workflow-orchestration/flows/06_gcp_taxi.yaml
from airflow import DAG
from airflow.operators.empty import EmptyOperator
from airflow.operators.branch import BaseBranchOperator
from airflow.operators.bash import BashOperator
from airflow.operators.python import PythonOperator
from airflow.utils.task_group import TaskGroup
from datetime import datetime, timedelta
from airflow.providers.google.cloud.transfers.local_to_gcs import (
    LocalFilesystemToGCSOperator,
)
from airflow.providers.google.cloud.operators.bigquery import (
    BigQueryCreateTableOperator,
    BigQueryInsertJobOperator,
)

import logging
from airflow.models import Variable
from airflow.utils.decorators import apply_defaults
from airflow.utils.trigger_rule import TriggerRule
import requests
import os

logger = logging.getLogger(__name__)
default_args = {
    "owner": "airflow",
    "retries": 1,
}

BUCKET_NAME = Variable.get("GCS_BUCKET_NAME", default_var=None)
PROJECT_ID = Variable.get("GCP_PROJECT_ID", default_var=None)
DATASET_ID = Variable.get("BIGQUERY_DATASET_ID", default_var=None)
yellow_table_field = [
    {
        "name": "unique_row_id",
        "type": "BYTES",
        "description": "A unique identifier for the trip, generated by hashing key trip attributes.",
    },
    {
        "name": "filename",
        "type": "STRING",
        "description": "The source filename from which the trip data was loaded.",
    },
    {
        "name": "VendorID",
        "type": "STRING",
        "description": "A code indicating the LPEP provider that provided the record. 1= Creative Mobile Technologies, LLC; 2= VeriFone Inc.",
    },
    {
        "name": "tpep_pickup_datetime",
        "type": "TIMESTAMP",
        "description": "The date and time when the meter was engaged.",
    },
    {
        "name": "tpep_dropoff_datetime",
        "type": "TIMESTAMP",
        "description": "The date and time when the meter was disengaged.",
    },
    {
        "name": "passenger_count",
        "type": "INTEGER",
        "description": "The number of passengers in the vehicle. This is a driver-entered value.",
    },
    {
        "name": "trip_distance",
        "type": "NUMERIC",
        "description": "The elapsed trip distance in miles reported by the taximeter.",
    },
    {
        "name": "RatecodeID",
        "type": "STRING",
        "description": "The final rate code in effect at the end of the trip. 1= Standard rate 2=JFK 3=Newark 4=Nassau or Westchester 5=Negotiated fare 6=Group ride.",
    },
    {
        "name": "store_and_fwd_flag",
        "type": "STRING",
        "description": "This flag indicates whether the trip record was held in vehicle memory before sending to the vendor, aka 'store and forward,' because the vehicle did not have a connection to the server. TRUE = store and forward trip, FALSE = not a store and forward trip.",
    },
    {
        "name": "PULocationID",
        "type": "STRING",
        "description": "TLC Taxi Zone in which the taximeter was engaged.",
    },
    {
        "name": "DOLocationID",
        "type": "STRING",
        "description": "TLC Taxi Zone in which the taximeter was disengaged.",
    },
    {
        "name": "payment_type",
        "type": "INTEGER",
        "description": "A numeric code signifying how the passenger paid for the trip. 1= Credit card 2= Cash 3= No charge 4= Dispute 5= Unknown 6= Voided trip.",
    },
    {
        "name": "fare_amount",
        "type": "NUMERIC",
        "description": "The time-and-distance fare calculated by the meter.",
    },
    {
        "name": "extra",
        "type": "NUMERIC",
        "description": "Miscellaneous extras and surcharges. Currently, this only includes the $0.50 and $1 rush hour and overnight charges.",
    },
    {
        "name": "mta_tax",
        "type": "NUMERIC",
        "description": "$0.50 MTA tax that is automatically triggered based on the metered rate in use.",
    },
    {
        "name": "tip_amount",
        "type": "NUMERIC",
        "description": "Tip amount. This field is automatically populated for credit card tips. Cash tips are not included.",
    },
    {
        "name": "tolls_amount",
        "type": "NUMERIC",
        "description": "Total amount of all tolls paid in trip.",
    },
    {
        "name": "improvement_surcharge",
        "type": "NUMERIC",
        "description": "$0.30 improvement surcharge assessed on hailed trips at the flag drop. The improvement surcharge began being levied in 2015.",
    },
    {
        "name": "total_amount",
        "type": "NUMERIC",
        "description": "The total amount charged to passengers. Does not include cash tips.",
    },
    {
        "name": "congestion_surcharge",
        "type": "NUMERIC",
        "description": "Congestion surcharge applied to trips in congested zones.",
    },
]
yellow_ext_table_field = [
    {
        "name": "VendorID",
        "type": "STRING",
        "mode": "NULLABLE",
        "description": "A code indicating the LPEP provider that provided the record. 1= Creative Mobile Technologies, LLC; 2= VeriFone Inc.",
    },
    {
        "name": "tpep_pickup_datetime",
        "type": "TIMESTAMP",
        "mode": "NULLABLE",
        "description": "The date and time when the meter was engaged",
    },
    {
        "name": "tpep_dropoff_datetime",
        "type": "TIMESTAMP",
        "mode": "NULLABLE",
        "description": "The date and time when the meter was disengaged",
    },
    {
        "name": "passenger_count",
        "type": "INTEGER",
        "mode": "NULLABLE",
        "description": "The number of passengers in the vehicle. This is a driver-entered value.",
    },
    {
        "name": "trip_distance",
        "type": "NUMERIC",
        "mode": "NULLABLE",
        "description": "The elapsed trip distance in miles reported by the taximeter.",
    },
    {
        "name": "RatecodeID",
        "type": "STRING",
        "mode": "NULLABLE",
        "description": "The final rate code in effect at the end of the trip. 1= Standard rate 2=JFK 3=Newark 4=Nassau or Westchester 5=Negotiated fare 6=Group ride",
    },
    {
        "name": "store_and_fwd_flag",
        "type": "STRING",
        "mode": "NULLABLE",
        "description": "This flag indicates whether the trip record was held in vehicle memory before sending to the vendor, aka 'store and forward,' because the vehicle did not have a connection to the server. TRUE = store and forward trip, FALSE = not a store and forward trip",
    },
    {
        "name": "PULocationID",
        "type": "STRING",
        "mode": "NULLABLE",
        "description": "TLC Taxi Zone in which the taximeter was engaged",
    },
    {
        "name": "DOLocationID",
        "type": "STRING",
        "mode": "NULLABLE",
        "description": "TLC Taxi Zone in which the taximeter was disengaged",
    },
    {
        "name": "payment_type",
        "type": "INTEGER",
        "mode": "NULLABLE",
        "description": "A numeric code signifying how the passenger paid for the trip. 1= Credit card 2= Cash 3= No charge 4= Dispute 5= Unknown 6= Voided trip",
    },
    {
        "name": "fare_amount",
        "type": "NUMERIC",
        "mode": "NULLABLE",
        "description": "The time-and-distance fare calculated by the meter",
    },
    {
        "name": "extra",
        "type": "NUMERIC",
        "mode": "NULLABLE",
        "description": "Miscellaneous extras and surcharges. Currently, this only includes the $0.50 and $1 rush hour and overnight charges",
    },
    {
        "name": "mta_tax",
        "type": "NUMERIC",
        "mode": "NULLABLE",
        "description": "$0.50 MTA tax that is automatically triggered based on the metered rate in use",
    },
    {
        "name": "tip_amount",
        "type": "NUMERIC",
        "mode": "NULLABLE",
        "description": "Tip amount. This field is automatically populated for credit card tips. Cash tips are not included.",
    },
    {
        "name": "tolls_amount",
        "type": "NUMERIC",
        "mode": "NULLABLE",
        "description": "Total amount of all tolls paid in trip.",
    },
    {
        "name": "improvement_surcharge",
        "type": "NUMERIC",
        "mode": "NULLABLE",
        "description": "$0.30 improvement surcharge assessed on hailed trips at the flag drop. The improvement surcharge began being levied in 2015.",
    },
    {
        "name": "total_amount",
        "type": "NUMERIC",
        "mode": "NULLABLE",
        "description": "The total amount charged to passengers. Does not include cash tips.",
    },
    {
        "name": "congestion_surcharge",
        "type": "NUMERIC",
        "mode": "NULLABLE",
        "description": "Congestion surcharge applied to trips in congested zones",
    },
]


class CheckTaxiTypeBranch(BaseBranchOperator):
    template_fields = ["taxi_type"]

    @apply_defaults
    def __init__(self, taxi_type: str, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.taxi_type = taxi_type

    def choose_branch(self, context):
        logger.info(f"taxi_type {self.taxi_type}")
        if self.taxi_type == "yellow":
            return "yellow_taxi_branch"
        elif self.taxi_type == "green":
            return "green_taxi_branch"
        return "empty_branch"


def extract_data(taxi_type: str, output_file: str, year: str, month: str):
    """_summary_

    Args:
        taxi_type: taxi_type from dag config
        output_file (_type_): File save in container
        year (_type_):
        month (_type_):

    Download file from github and unzip it
    """
    logger.info("Starting Download file from source")
    download_file = f"{taxi_type}_tripdata_{year}-{month}.csv.gz"
    url = f"https://github.com/DataTalksClub/nyc-tlc-data/releases/download/{taxi_type}/{download_file}"
    logger.info(f"Download file from URL {url}")
    # Download the file
    response = requests.get(url)
    response.raise_for_status()  # Raise an exception for HTTP errors

    # Write the downloaded content
    with open(output_file, "wb") as f:
        f.write(response.content)

    # If it's a gzipped file, extract it
    if output_file.endswith(".gz"):
        import gzip
        import shutil

        # Extract the gzipped file
        with gzip.open(output_file, "rb") as f_in:
            with open(output_file.replace(".gz", ""), "wb") as f_out:
                shutil.copyfileobj(f_in, f_out)

        # # Optional: Remove the original .gz file
        os.remove(output_file)
    logger.info("Success download")
    return output_file


with DAG(
    "download_file_and_upload_to_gcp",
    schedule=None,
    start_date=datetime(2025, 1, 1),
    dagrun_timeout=timedelta(minutes=45),
) as dag:
    # Get all params from input and define necessary variable
    taxi_type = "{{ dag_run.conf.get('taxi_type', 'default') }}"
    year = "{{ dag_run.conf.get('year') }}"
    month = "{{ dag_run.conf.get('month') }}"
    table_name = f"{taxi_type}_tripdata"
    table_staging = f"{table_name}_{year}_{month}"
    time = f"{year}_{month}"
    file_name = f"{taxi_type}_tripdata_{year}-{month}"
    folder_save_file = "/tmp"
    url_download = f"https://github.com/DataTalksClub/nyc-tlc-data/releases/download/{taxi_type}/{file_name}.csv.gz"
    taxi_type_branch = CheckTaxiTypeBranch(
        task_id="get_taxi_type_branch_task", taxi_type=taxi_type
    )
    yellow_taxi_branch = EmptyOperator(task_id="yellow_taxi_branch")
    green_taxi_branch = EmptyOperator(task_id="green_taxi_branch")
    empty_branch = EmptyOperator(task_id="empty_branch")
    # Task group handle download file and unzip file csv.gz -> csv
    download_file_and_unzip = PythonOperator(
        task_id=f"download_data",
        python_callable=extract_data,
        op_args=[taxi_type, f"{folder_save_file}/{file_name}.csv.gz", year, month],
        execution_timeout=timedelta(minutes=10),
        provide_context=True,
        trigger_rule=TriggerRule.ONE_SUCCESS,
    )

    # Upload file to GCS
    with TaskGroup(
        group_id="upload_to_gcs_and_remove_local"
    ) as upload_to_gcs_and_remove_local:
        upload_file = LocalFilesystemToGCSOperator(
            task_id="upload_file",
            src=f"{folder_save_file}/{file_name}.csv",
            dst=f"{file_name}.csv",
            bucket=BUCKET_NAME,
            gcp_conn_id="gcp_connection",
        )
        remove_file = BashOperator(
            task_id="remove_file",
            bash_command=f'[ -f "{folder_save_file}/{file_name}.csv" ] && rm "{folder_save_file}/{file_name}.csv" || echo "File not found, skipping..."',
            dag=dag,
        )
        upload_file >> remove_file
    # Can replace with BigQueryInsertJobOperator
    create_table = BigQueryCreateTableOperator(
        task_id="create_table",
        dataset_id=DATASET_ID,
        table_id=f"{table_name}",
        gcp_conn_id="gcp_connection",
        table_resource={
            "schema": {"fields": yellow_table_field},
            "timePartitioning": {
                "type": "DAY",  # Partitioning by day
                "field": "tpep_pickup_datetime",  # Partition column (must be DATE or TIMESTAMP)
            },
        },
    )
    # Can replace with BigQueryInsertJobOperator
    create_table_ex = BigQueryCreateTableOperator(
        task_id="create_table_ext",
        dataset_id=DATASET_ID,
        gcp_conn_id="gcp_connection",
        table_id=f"{table_staging}_ext",
        table_resource={
            "schema": {"fields": yellow_ext_table_field},
            "externalDataConfiguration": {
                "sourceUris": [f"gs://{BUCKET_NAME}/{file_name}.csv"],
                "sourceFormat": "CSV",
                "csvOptions": {"skipLeadingRows": 1},
                "autodetect": True,
            },
        },
    )
    bq_create_replace_table = BigQueryInsertJobOperator(
        task_id="bq_create_replace_table",
        gcp_conn_id="gcp_connection",
        configuration={
            "query": {
                "query": f"""
                    CREATE OR REPLACE TABLE `{DATASET_ID}.{table_staging}` AS
                    SELECT
                        MD5(CONCAT(
                        COALESCE(CAST(VendorID AS STRING), ""),
                        COALESCE(CAST(tpep_pickup_datetime AS STRING), ""),
                        COALESCE(CAST(tpep_dropoff_datetime AS STRING), ""),
                        COALESCE(CAST(PULocationID AS STRING), ""),
                        COALESCE(CAST(DOLocationID AS STRING), "")
                        )) AS unique_row_id,
                        "{BUCKET_NAME}/{file_name}.csv" AS filename,
                        *
                    FROM `{DATASET_ID}.{table_staging}_ext`;
                """,
                "useLegacySql": False,
            }
        },
        dag=dag,
    )
    bq_merge_task = BigQueryInsertJobOperator(
        task_id="bq_yellow_merge",
        configuration={
            "query": {
                "query": f"""
                    MERGE INTO `{DATASET_ID}.{table_name}` T
                    USING `{DATASET_ID}.{table_staging}` S
                    ON T.unique_row_id = S.unique_row_id
                    WHEN NOT MATCHED THEN
                    INSERT (unique_row_id, filename, VendorID, tpep_pickup_datetime, tpep_dropoff_datetime, passenger_count, trip_distance, RatecodeID, store_and_fwd_flag, PULocationID, DOLocationID, payment_type, fare_amount, extra, mta_tax, tip_amount, tolls_amount, improvement_surcharge, total_amount, congestion_surcharge)
                    VALUES (S.unique_row_id, S.filename, S.VendorID, S.tpep_pickup_datetime, S.tpep_dropoff_datetime, S.passenger_count, S.trip_distance, S.RatecodeID, S.store_and_fwd_flag, S.PULocationID, S.DOLocationID, S.payment_type, S.fare_amount, S.extra, S.mta_tax, S.tip_amount, S.tolls_amount, S.improvement_surcharge, S.total_amount, S.congestion_surcharge);
                """,
                "useLegacySql": False,
            }
        },
        gcp_conn_id="gcp_connection",
        dag=dag,
    )
    # create_table_bigquery = BigQueryCreateTableOperator(
    #     dataset_id=DATASET_ID, gcp_conn_id="gcp_connection", if_exists=True
    # )

    taxi_type_branch >> [yellow_taxi_branch, green_taxi_branch, empty_branch]
    yellow_taxi_branch >> download_file_and_unzip
    green_taxi_branch >> download_file_and_unzip
    (
        download_file_and_unzip
        >> upload_to_gcs_and_remove_local
        >> create_table
        >> create_table_ex
        >> bq_create_replace_table
        >> bq_merge_task
    )
